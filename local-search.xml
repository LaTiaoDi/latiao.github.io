<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Session与JWT</title>
    <link href="/2021/02/26/%E8%AE%A4%E8%AF%81/"/>
    <url>/2021/02/26/%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Session-认证机制与JWT认证机制"><a href="#Session-认证机制与JWT认证机制" class="headerlink" title="Session 认证机制与JWT认证机制"></a><strong>Session</strong> 认证机制与JWT认证机制</h2><h4 id="1、不同开发模式下的身份认证"><a href="#1、不同开发模式下的身份认证" class="headerlink" title="1、不同开发模式下的身份认证"></a>1、<strong>不同开发模式下的</strong>身份认证</h4><ul><li>服务端渲染推荐使用Session认证机制</li><li>前后端分离推荐用JWT认证机制</li></ul><h4 id="2、Session-认证机制"><a href="#2、Session-认证机制" class="headerlink" title="2、Session 认证机制"></a>2、Session 认证机制</h4><ul><li><p>Cookie 是<strong>存储在用户浏览器中的一段不超过 4 KB 的字符串</strong>。它由一个名称（Name）、一个值（Value）和其它几个用</p><p>于控制 Cookie 有效期、安全性、使用范围的可选属性组成。</p><p>不同域名下的 Cookie 各自独立，每当客户端发起请求时，会<strong>自动</strong>把<strong>当前域名下</strong>所有<strong>未过期的 Cookie</strong> 一同发送到服务器。</p><p><strong>Cookie的几大特性：</strong></p><p>① 自动发送</p><p>② 域名独立</p><p>③ 过期时限</p><p>④ 4KB 限制</p></li><li><p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie,客户端会自动将Cookie保存在浏览器中。</p><p>随后当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份</p></li><li><p><strong>Cookie不具有安全性</strong></p><p>由于Cookie是存储在浏览器中的，而且浏览器也提供了读写Cookie的APi，因此Cookie很容易被伪造，不具有安全性，因此不建议服务器将重要的隐私数据，通过Cookie的形式发送给浏览器</p></li><li><p>Sessionr认证机制需要被和Cookie才能实现。由于Cookie默认不支持跨域访问，所以，当涉及前端跨域请求后端口的时候，需要做很多额外的配置，才能实现跨越Session认证</p></li></ul><h4 id="3、JWT认证机制"><a href="#3、JWT认证机制" class="headerlink" title="3、JWT认证机制"></a>3、JWT认证机制</h4><ul><li><p>JWT（全称 JSON Web Token ）是目前最流行的跨域认证解决方案</p></li><li><p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。</p></li><li><p>JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。</p><p>其中：</p><p>⚫ <strong>Payload</strong> 部分<strong>才是真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串。</p><p>⚫ Header 和 Signature 是<strong>安全性相关</strong>的部分，只是为了保证 Token 的安全性。</p></li><li><p><strong>JWT 的</strong>使用方式</p><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。推荐的做法是<strong>把 JWT 放在 HTTP 请求头的 Authorization 字段</strong></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql教程</title>
    <link href="/2021/02/25/mysql/"/>
    <url>/2021/02/25/mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="mySQL教程"><a href="#mySQL教程" class="headerlink" title="mySQL教程"></a>mySQL教程</h2><h3 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h3><p>​    一、查询表中所有数据</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名称<br></code></pre></td></tr></table></figure><p>​    二、向数据表中插入新的数据行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into 表名称 (列<span class="hljs-number">1</span>，列<span class="hljs-number">2</span>，...)values (值<span class="hljs-number">1</span>，值<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>​     三、修改表中的数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> 表名称 <span class="hljs-keyword">set</span> 列名称 = 新增 <span class="hljs-keyword">where</span> 列名称=某值<br></code></pre></td></tr></table></figure><p>​    四、删除表中数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名称 <span class="hljs-keyword">where</span> 列名称 = 值<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>node教程</title>
    <link href="/2021/02/22/node/"/>
    <url>/2021/02/22/node/</url>
    
    <content type="html"><![CDATA[<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h5 id="1-npm命令"><a href="#1-npm命令" class="headerlink" title="1.npm命令"></a>1.npm命令</h5><ul><li>npm -v 查看npm版本</li><li>npm -install (简写 -i) xxx 安装指定内容的包</li><li>npm init -y 快速创建package.json包管理配置文件</li><li>npm install 一次性安装所有的依赖包</li><li>npm uninstall 卸载包</li><li>npm i 包名 -D 或 npm install xx –save-dev 将包记录到devDepndencies上</li><li>npm i xxx -g     #安装全局包</li><li>npm uninstall xx -g #卸载全局包</li></ul><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><ul><li>dependencies 记录使用npm install 安装的包</li><li>devDepndencies 记录只在开发阶段使用的包，比如webpack</li></ul><h2 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a><strong>规范的包结构</strong></h2><ol><li>包必须以单独的目录而存在</li><li>包的顶级目录下要必须包含 package.json 这个包管理配置文件</li><li>package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。</li></ol><h2 id="node模块加载机制"><a href="#node模块加载机制" class="headerlink" title="node模块加载机制"></a>node模块加载机制</h2><ol><li><p><strong>模块在第一次加载后会被缓存</strong>。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。</p><p>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。</p></li><li><p><strong>内置模块</strong>的加载机制</p><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。</p><p>例如，require(‘fs’) 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs</p></li><li><p><strong>自定义模块</strong>的加载机制</p><p>使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 ../ </p><p>这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p><p>同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：</p><p>① 按照确切的文件名进行加载</p><p>② 补全 .js 扩展名进行加载</p><p>③ 补全 .json 扩展名进行加载</p><p>④ 补全 .node 扩展名进行加载</p><p>⑤ 加载失败，终端报错</p></li><li><p><strong>第三方模块</strong>的加载机制</p><p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父</p><p>目录开始，尝试从 /node_modules 文件夹中加载第三方模块。</p><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。</p><p>例如，假设在 ‘C:\Users\itheima\project\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p><p>① C:\Users\itheima\project\node_modules\tools</p><p>② C:\Users\itheima\node_modules\tools</p><p>③ C:\Users\node_modules\tools</p><p>④ C:\node_modules\tools</p></li><li><p><strong>目录</strong>作为模块</p><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：</p><p>① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</p><p>② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。 </p><p>③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>沈庆的博客</title>
    <link href="/2021/01/28/My-New-Post/"/>
    <url>/2021/01/28/My-New-Post/</url>
    
    <content type="html"><![CDATA[<h3 id="你好世界"><a href="#你好世界" class="headerlink" title="你好世界"></a>你好世界</h3><h3 id="李俊牛逼"><a href="#李俊牛逼" class="headerlink" title="李俊牛逼"></a>李俊牛逼</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello 沈庆</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
